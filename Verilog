Verilog is a Hardware Describtion Language. An HDL is used to describe a digital system 
[microprocessor, memory, flip-flop, network switch...] => any hardware [digita] at any level
could be described by using HDL. Verilog describes digital desigh at behavior level Register
Transfer Level [RTL],Gate level and a switch level.Verilog allows designers to express their
design with behavioral construct, implementing the deasign's later stage into final.
[It may not take more then one week if you know at least 1 programming language].
Verilog as any HDL allows to describe or Bottom-up[each design is performed gate-level.This bottom-up
allows to a new way to hierachical and strutural design methods] or Top-down methodology[allows early 
testing, choise of different technologies but are complicated thus sometimes they mix both methods].


Levels of abstruction

1. Behavioral Level [algorithms each of them itself is sequential which means it contains a set of 
instructions which are executed one after another. functions, tasks and always blocks are main 
elements, no regard to structural design]
2.Register transfer [characteristics of a circuit by operations and the transfer of data between 
the registers. Any synthesable code is called RTL code]
3. Gate level [code is generated using synthesis tools and thisnetlist is used for simulationa
and backend. In this level the systems are desribed by logical gates and by their timings.
This level does not fit to any level of logic design.All signals are discrete==only have defined one 
value like 0,1,x,z]

Speccification

Defining the important parameters of the system design. Microsoft Word, or GNU Abiword are a good 
options for entering the speciffications.

Highh Level Design

A stage where varius blocks in the design and comunications between them are defined. High level design 
means spliting the system[design] into blocks by teir functionalities The blocs of registers , ALU,
instruction Decode, memory interface...Entering high level design is able to be done by Microsoft Word, or KWriter or

Micro Design [Low Level Design]

Phase which designer describes how each block is implemented. Containes details of the State machines, counters, Mux,
decoders, internal registers. StateCAD and word are used for state machiene entry. 

RTL coding
Using synthesizable constructs of the language Micro Design is converted into Verilog/VHDL code [in RTL] 
Using vim editor [ TEXT, Nedit, Emacs...]

1 -> module smth (
2 -> a, //first input
3 -> b, //second
4 -> ci, //carry input
5 -> sum, // output the sum
6 -> co, // carry output
7 -> ); // Do not forget the semicol.s ;)
8 -> //input decleration
9 -> input a;
10 ->input b;
11 -> input i;
12 -> // output deceleration
13 -> ouatput sum;
14 -> output co;
15 -> //Port data type
16 -> wire a;
17 -> wire b;
18 -> wire ci;
19 -> wire sum;
20 -> wire co;
21 -> // Start the code;
22 -> asign {co,sum} = a+b+ci;
23 -> endmodule // end of module smth

Simulation

Is the verification process of functions for any level of abstruction.
To see all blocks functionality correction we create a testbench wich 
creates clock [generates].We use waveform output viewer to see if the DUT [Device Under Test] is functionally correct.
Timing simulation is done after synthesis or after P&R [place & route].Here we include gate delays & wire delays to see
DUT works at rated clock speed. Also called as SDF simulation or gate level simulation.

Synthesis

Is a process in which synthesis tool [like design compiler or synplify] takes the RTL in Verilog or VHDL, target technology 
and constrains as inputs and maps the RTL to target technology primitives.Syntesis tools after mapping the RTL to gates, also
do the minimal amount of timing analyse to see if the mapping meets the required timing requirements. [they know only gate 
delays not the wire ones. ater netlist

Formal verification [checking if the RTL to gate is correct]
scan insertion [insert the scan chain in case of ASIC]

and then backend is done [place & routing]

Place & Route

Gatelevel netlist from the synthesis tool is taken and imported into P&R tool in verilog netlist format. All the gates and
flip-flops are placed, clock tree synthesis and reset is routed. Afteer which , each block is routed. The P&R tool give 
GDS output file which is used by foundary for fabrication the ASIC. P&R tools are used to output the SDF files,into static
analysis tool like Prime Time to do timing analysis.

Post Silicon Validation

Before the chiip [chip] is released into market, it needs to put in real enviroment and tested. Since the speed of 
simulation with RTL is very slow [number of clocks per second]] thus exists possibility to find a bug in post silicon
validation.

1 -> module The_First_Program;
2 -> initial begin  
3 -> $display ("smth");
4 -> #10$finish;
5 -> end
6 -> endmodule

Any Program in Verilog stats with reserved word module,also  able having compiler pre-processor statements
[include,define statements before module decleration] 
The initial block gets executed only once after simulation starts at time=0 , contains 2 statements, which are closed 
within begin & end. If there are multiple lines with a block, begin & end are needed.

Counter

Number of flip-flops connected in cascade.
Asynchronous [ripple] is a single d-type flip-flop with J input. Incr once for every clock sycle and takes 2 clock
cycles to overflow, so every cycle will alternate between transition from 0 -1 & from 1-0. Creates new clock with a
50% duty cycle [the fraction of one period in wich a signal or system is active and expressed as a percentage or a 
ratio. A period is the time it takes for a signal to complete a cycle of on-&-off.As formula => D=PW/T*100%.
Where PW == pulse width[pulse active time], T == total time period of the signal.So e.g. 75% DC could be fraction
of a second , signal is on 75% of the time [depending on the length of the period] but 35% is off of the time. at
exactly half the frequency of the input clock. DC is also used to describe the active time of an active signal
s.t. as a power switch in a switching power supply, action potentioals in a living systems s.t. neuron.] 

module a_counter(
clock, //Clock input 
reset, // active high sync. reset input
enable, // active high enable signal for counter
counter_out // 4 bit output of the counter
); // end port ls
//input ports
input clock;
input reset;
input enable;
// output ports
output [3:0] counter_out;
//input ports data type
// all inputs should be wires
wire clock;
wire reset ;
wire enable;
//output ports
// could be storage element [reg] or a wire
reg [3:0] counter_out;
//begin code
//counter is positive edge => the block with positive edge of clock.
always @ (posedge clockk)
begin : Counter // block name
// check if the clock is active at every rising edge.If actibve=>load.
if (reset==1'b1) begin
	counter_out <=# 4'b0000;
 end
//if enable active=> write incr counter
 else if (enable ==1'b1) begin
	counter_out<= #1 counter_out+1;
 end
end //block counter

endmodule

COUNTER_TEST_BENCH


3 
Assign [w2w]
Blocking [== ; elemento cascade nerov ancnel vortegh elementnery the scheme decides== self timed ]

Non-blocking [<= ; clk tree the event occurs at the same time in dif peaces- the event decides]
Akntartoren => sxal ardyunq 

